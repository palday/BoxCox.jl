var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = BoxCox\nDocTestSetup = quote\n    using BoxCox\nend\nDocTestFilters = [r\"([a-z]*) => \\1\", r\"getfield\\(.*##[0-9]+#[0-9]+\"]","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [BoxCox]\nPrivate = false","category":"page"},{"location":"api/#BoxCox.BoxCoxTransformation","page":"API","title":"BoxCox.BoxCoxTransformation","text":"struct BoxCoxTransformation <: PowerTransformation\n\nFields\n\nλ: The transformation parameter\ny: The original response, normalized by its geometric mean\nX: A model matrix for the conditional distribution or Nothing for the unconditional distribution\natol: Tolerance for comparing λ to zero. Default is 1e-8\n\nnote: Note\nAll fields are considered internal and implementation details and may change at any time without being considered breaking.\n\nTips\n\nTo extract the λ parameter, use params.\nThe transformation is callable, meaning that you can do\n\nbc = fit(BoxCoxTransformation, y)\ny_transformed = bc.(y)\n\nYou can reduce the size of a BoxCoxTransformation in memory by using empty!, but certain diagnostics (e.g. plotting and computation of the loglikelihood will no longer be available).\n\nSee also boxcoxplot, params, boxcox.\n\n\n\n\n\n","category":"type"},{"location":"api/#BoxCox.BoxCoxTransformation-Tuple{Number}","page":"API","title":"BoxCox.BoxCoxTransformation","text":"(t::BoxCoxTransformation)(x::Number)\n\nApply the estimated BoxCox transformation t to the number x.\n\nSee also BoxCox.\n\n\n\n\n\n","category":"method"},{"location":"api/#BoxCox.boxcox-Tuple{Any}","page":"API","title":"BoxCox.boxcox","text":"boxcox(λ; atol=0)\nboxcox(λ, x; atol=0)\n\nCompute the Box-Cox transformation of x for the parameter value λ.\n\natol controls the absolute tolerance for treating λ as zero.\n\nThe one argument variant curries and creates a one-argument function of x for the given λ.\n\nSee also BoxCoxTransformation.\n\nReferences\n\nBox, George E. P.; Cox, D. R. (1964). \"An analysis of transformations\". Journal of the Royal Statistical Society, Series B. 26 (2): 211–252.\n\n\n\n\n\n","category":"method"},{"location":"api/#BoxCox.boxcoxplot!-Tuple{Any, BoxCox.PowerTransformation}","page":"API","title":"BoxCox.boxcoxplot!","text":"boxcoxplot(bc::BoxCoxTransformation; kwargs...)\nboxcoxplot!(axis, bc::BoxCoxTransformation; λ=nothing, n_steps=21)\n\nCreate a diagnostic plot for the Box-Cox transformation.\n\nIf λ is nothing, the range of possible values for the λ paramter is automatically determined, with a total of n_steps. If λ is a vector of numbers, then the λ parameter is evaluated at each element of that vector.\n\nnote: Note\nYou must load an appropriate Makie backend (e.g., CairoMakie or GLMakie) to actually render a plot.\n\nnote: Note\nA meaningful plot is only possible when bc has not been empty!'ed.\n\ncompat: Julia 1.6\nThe plotting functionality is defined unconditionally.\n\ncompat: Julia 1.9\nThe plotting functionality interface is defined as a package extension and only loaded when Makie is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#BoxCox.boxcoxplot-Tuple{BoxCox.PowerTransformation}","page":"API","title":"BoxCox.boxcoxplot","text":"boxcoxplot(bc::BoxCoxTransformation; kwargs...)\nboxcoxplot!(axis, bc::BoxCoxTransformation; λ=nothing, n_steps=21)\n\nCreate a diagnostic plot for the Box-Cox transformation.\n\nIf λ is nothing, the range of possible values for the λ paramter is automatically determined, with a total of n_steps. If λ is a vector of numbers, then the λ parameter is evaluated at each element of that vector.\n\nnote: Note\nYou must load an appropriate Makie backend (e.g., CairoMakie or GLMakie) to actually render a plot.\n\nnote: Note\nA meaningful plot is only possible when bc has not been empty!'ed.\n\ncompat: Julia 1.6\nThe plotting functionality is defined unconditionally.\n\ncompat: Julia 1.9\nThe plotting functionality interface is defined as a package extension and only loaded when Makie is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.confint-Tuple{BoxCoxTransformation}","page":"API","title":"StatsAPI.confint","text":"StatsAPI.confint(bc::BoxCoxTransformation; level::Real=0.95, fast::Bool=nobs(bc) > 10_000)\n\nCompute confidence intervals for λ, with confidence level level (by default 95%).\n\nIf fast, then a symmetric confidence interval around ̂λ is assumed and the upper bound is computed using the difference between the lower bound and λ. Symmetry is generally a safe assumption for approximate values and halves computation time.\n\nIf not fast, then the lower and upper bounds are computed separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit-Tuple{Type{BoxCoxTransformation}, AbstractVector{<:Number}}","page":"API","title":"StatsAPI.fit","text":"StatsAPI.fit(::Type{BoxCoxTransformation}, y::AbstractVector{<:Number}; atol=1e-8,\n             algorithm::Symbol=:LN_BOBYQA, opt_atol=1e-8, opt_rtol=1e-8,\n            maxiter=-1)\nStatsAPI.fit(::Type{BoxCoxTransformation}, X::AbstractMatrix{<:Number},\n             y::AbstractVector{<:Number}; atol=1e-8,\n             algorithm::Symbol=:LN_BOBYQA, opt_atol=1e-8, opt_rtol=1e-8,\n             maxiter=-1)\nStatsAPI.fit(::Type{BoxCoxTransformation}, formula::FormulaTerm, data;\n             atol=1e-8,\n             algorithm::Symbol=:LN_BOBYQA, opt_atol=1e-8, opt_rtol=1e-8,\n             maxiter=-1)\nStatsAPI.fit(::Type{BoxCoxTransformation}, model::LinearMixedModel;\n             atol=1e-8, progress=true,\n             algorithm::Symbol=:LN_BOBYQA, opt_atol=1e-8, opt_rtol=1e-8,\n             maxiter=-1)\n\nFind the optimal λ value for a Box-Cox transformation of the data.\n\nWhen no X is provided, y is treated as an unconditional distribution.\n\nWhen X is provided, y is treated as distribution conditional on the linear predictor defined by X. At each iteration step, a simple linear regression is fit to the transformed y with X as the model matrix.\n\nIf a FormulaTerm is provided, then X is constructed using that specification and data.\n\nIf a LinearMixedModel is provided, then X and y are extracted from the model object.\n\nnote: Note\nThe formula interface is only available if StatsModels.jl is loaded either directly or via another package such GLM.jl or MixedModels.jl.\n\ncompat: Julia 1.6\nThe formula interface is defined unconditionally, but @formula is not loaded.\nThe MixedModels interface is defined unconditionally.\n\ncompat: Julia 1.9\nThe formula interface is defined as a package extension.\nThe MixedModels interface is defined as a package extension.\n\natol controls the absolute tolerance for treating λ as zero.\n\nThe opt_ keyword arguments are tolerances passed onto NLopt.\n\nmaxiter specifies the maximum number of iterations to use in optimization; negative values place no restriciton.\n\nalgorithm is a valid NLopt algorithm to use in optimization.\n\nprogress enables progress bars for intermediate model fits during the optimization process.\n\n\n\n\n\n","category":"method"},{"location":"#BoxCox.jl-Documentation","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"","category":"section"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"CurrentModule = BoxCox","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"BoxCox.jl is a Julia package providing an implementation of the Box-Cox transformation and generalizations thereof.","category":"page"},{"location":"#Box-Cox-transformations-of-an-unconditional-distribution","page":"BoxCox.jl Documentation","title":"Box-Cox transformations of an unconditional distribution","text":"","category":"section"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"First, we consider applying the Box-Cox transformation to an unconditional distribution. In other words, we have a vector of data that we wish to be more Gaussian in shape.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We start with the square root of a normal distribution.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"using BoxCox\nusing CairoMakie\nusing Random\nx = abs2.(randn(MersenneTwister(42), 1000))\nhist(x)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"qqnorm(x)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We fit the Box-Cox transform.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"bc = fit(BoxCoxTransformation, x)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"Note that the resulting transform isn't exactly a square root, even though our data are just the square of a normal sample. The reason for this is simple: without knowing the original sign, the square root returns all positive values and would thus not generate a symmetric distribution. The Box-Cox transformation does not eliminate the use of the analyst's discretion and domain knowledge.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"Now that we've fit the transform, we use it like a function to transform the original data.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"hist(bc.(x))","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"There is also a special method for qqnorm provided for objects of type BoxCoxTransformation, which shows the QQ plot of the transformation applied to the original data.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"qqnorm(bc)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We can also generate a diagnostic plot to see how well other parameter values would have worked for normalizing the data.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"boxcoxplot(bc)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"The vertical line corresponds to the final parameter estimate. ","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"If we specify a confidence level, then an additional horizontal line is added, which crosses the likelihood profile at the points corresponding to the edge of the confidence interval.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"boxcoxplot(bc; conf_level=0.95)","category":"page"},{"location":"#Box-Cox-transformations-of-a-conditional-distribution","page":"BoxCox.jl Documentation","title":"Box-Cox transformations of a conditional distribution","text":"","category":"section"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We can also consider transformations of a conditional distribution. As an example, we consider the trees dataset:","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"using BoxCox\nusing CairoMakie\nusing RDatasets: dataset as rdataset\nusing StatsModels\n\ntrees = rdataset(\"datasets\", \"trees\")","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"For the conditional distribution, we want to fit a linear regression to the transformed response values and then evaluate the profile likelihood of the transformation. If the StatsModels package has been loaded, either directly or indirectly (e.g. via loading GLM.jl or MixedModels.jl), then a formula interface is available. (Otherwise, the model matrix and the response have to specified separately.)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"bc = fit(BoxCoxTransformation, @formula(Volume ~ log(Height) + log(Girth)), trees)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We can do all the same diagnostics as previously:","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"let f = Figure()\n    ax = Axis(f[1, 1]; title=\"Raw\")\n    hist!(ax, trees.Volume)\n    ax = Axis(f[1, 2]; title=\"Transformed\")\n    hist!(ax, bc.(trees.Volume))\n    f\nend","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"let f = Figure()\n    ax = Axis(f[1, 1]; title=\"Raw\", aspect=1)\n    qqnorm!(ax, trees.Volume; qqline=:fitrobust)\n    ax = Axis(f[1, 2]; title=\"Transformed\", aspect=1)\n    qqnorm!(ax, bc)\n    f\nend","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"boxcoxplot(bc; conf_level=0.95)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"This last diagnostic plot suggests that λ = 0 is within the possible range of parameter values to consider.  λ = 0 corresponds to a logarithmic transformation; given that the other variables are log-transformed, this suggests that we should consider using a log transform for the response.","category":"page"}]
}
