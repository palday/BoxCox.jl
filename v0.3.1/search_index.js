var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = BoxCox\nDocTestSetup = quote\n    using BoxCox\nend\nDocTestFilters = [r\"([a-z]*) => \\1\", r\"getfield\\(.*##[0-9]+#[0-9]+\"]","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [BoxCox]\nPrivate = false","category":"page"},{"location":"api/#BoxCox.BoxCoxTransformation","page":"API","title":"BoxCox.BoxCoxTransformation","text":"BoxCoxTransformation <: PowerTransformation\n\nFields\n\nλ: The transformation parameter\ny: The original response, normalized by its geometric mean\nX: A model matrix for the conditional distribution or Nothing for the unconditional distribution\natol: Tolerance for comparing λ to zero. Default is 1e-8\n\nnote: Note\nAll fields are considered internal and implementation details and may change at any time without being considered breaking.\n\nTips\n\nTo extract the λ parameter, use params.\nThe transformation is callable, meaning that you can do\n\nbc = fit(BoxCoxTransformation, y)\ny_transformed = bc.(y)\n\nYou can reduce the size of a BoxCoxTransformation in memory by using empty!, but certain diagnostics (e.g. plotting and computation of the loglikelihood will no longer be available).\n\nSee also boxcoxplot, params, boxcox.\n\n\n\n\n\n","category":"type"},{"location":"api/#BoxCox.BoxCoxTransformation-Tuple{Number}","page":"API","title":"BoxCox.BoxCoxTransformation","text":"(t::BoxCoxTransformation)(x::Number)\n\nApply the estimated BoxCox transformation t to the number x.\n\nSee also boxcox.\n\n\n\n\n\n","category":"method"},{"location":"api/#BoxCox.boxcox-Tuple{Any}","page":"API","title":"BoxCox.boxcox","text":"boxcox(λ; atol=0)\nboxcox(λ, x; atol=0)\n\nCompute the Box-Cox transformation of x for the parameter value λ.\n\nThe Box-Cox transformation is defined as:\n\nbegincases\nfracx^lambda - 1lambda quad lambda neq 0 \nlog x quad lambda = 0\nendcases\n\nfor positive x. (If x = 0, then x must first be translated to be strictly positive.)\n\natol controls the absolute tolerance for treating λ as zero.\n\nThe one argument variant curries and creates a one-argument function of x for the given λ.\n\nSee also BoxCoxTransformation.\n\nReferences\n\nBox, George E. P.; Cox, D. R. (1964). \"An analysis of transformations\". Journal of the Royal Statistical Society, Series B. 26 (2): 211–252.\n\n\n\n\n\n","category":"method"},{"location":"api/#BoxCox.boxcoxplot!-Tuple{Any, BoxCox.PowerTransformation}","page":"API","title":"BoxCox.boxcoxplot!","text":"boxcoxplot(bc::BoxCoxTransformation; kwargs...)\nboxcoxplot!(axis::Axis, bc::BoxCoxTransformation;\n            λ=nothing, n_steps=21, xlabel=\"λ\", ylabel=\"log likelihood\",\n            conf_level=nothing, attributes...)\n\nCreate a diagnostic plot for the Box-Cox transformation.\n\nThe mutating method for Axis returns the (modified) original Axis. The non-mutating method returns a Figure.\n\nIf λ is nothing, the range of possible values for the λ parameter is automatically determined, with a total of n_steps. If λ is a vector of numbers, then the λ parameter is evaluated at each element of that vector.\n\nIf conf_level is nothing, then no confidence interval is displayed.\n\nattributes are forwarded to scatterlines!.\n\nnote: Note\nA meaningful plot is only possible when bc has not been empty!'ed.\n\nnote: Note\nThe plotting functionality interface is defined as a package extension and only loaded when Makie is available. You must load an appropriate Makie backend (e.g., CairoMakie or GLMakie) to actually render a plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#BoxCox.boxcoxplot-Tuple{BoxCox.PowerTransformation}","page":"API","title":"BoxCox.boxcoxplot","text":"boxcoxplot(bc::BoxCoxTransformation; kwargs...)\nboxcoxplot!(axis::Axis, bc::BoxCoxTransformation;\n            λ=nothing, n_steps=21, xlabel=\"λ\", ylabel=\"log likelihood\",\n            conf_level=nothing, attributes...)\n\nCreate a diagnostic plot for the Box-Cox transformation.\n\nThe mutating method for Axis returns the (modified) original Axis. The non-mutating method returns a Figure.\n\nIf λ is nothing, the range of possible values for the λ parameter is automatically determined, with a total of n_steps. If λ is a vector of numbers, then the λ parameter is evaluated at each element of that vector.\n\nIf conf_level is nothing, then no confidence interval is displayed.\n\nattributes are forwarded to scatterlines!.\n\nnote: Note\nA meaningful plot is only possible when bc has not been empty!'ed.\n\nnote: Note\nThe plotting functionality interface is defined as a package extension and only loaded when Makie is available. You must load an appropriate Makie backend (e.g., CairoMakie or GLMakie) to actually render a plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.confint-Tuple{BoxCoxTransformation}","page":"API","title":"StatsAPI.confint","text":"StatsAPI.confint(bc::BoxCoxTransformation; level::Real=0.95, fast::Bool=nobs(bc) > 10_000)\n\nCompute confidence intervals for λ, with confidence level level (by default 95%).\n\nIf fast, then a symmetric confidence interval around ̂λ is assumed and the upper bound is computed using the difference between the lower bound and λ. Symmetry is generally a safe assumption for approximate values and halves computation time.\n\nIf not fast, then the lower and upper bounds are computed separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit-Tuple{Type{BoxCoxTransformation}, AbstractVector{<:Number}}","page":"API","title":"StatsAPI.fit","text":"StatsAPI.fit(::Type{BoxCoxTransformation}, y::AbstractVector{<:Number}; atol=1e-8,\n             algorithm::Symbol=:LN_BOBYQA, opt_atol=1e-8, opt_rtol=1e-8,\n            maxiter=-1)\nStatsAPI.fit(::Type{BoxCoxTransformation}, X::AbstractMatrix{<:Number},\n             y::AbstractVector{<:Number}; atol=1e-8,\n             algorithm::Symbol=:LN_BOBYQA, opt_atol=1e-8, opt_rtol=1e-8,\n             maxiter=-1)\nStatsAPI.fit(::Type{BoxCoxTransformation}, formula::FormulaTerm, data;\n             atol=1e-8,\n             algorithm::Symbol=:LN_BOBYQA, opt_atol=1e-8, opt_rtol=1e-8,\n             maxiter=-1)\nStatsAPI.fit(::Type{BoxCoxTransformation}, model::LinearMixedModel;\n             atol=1e-8, progress=true,\n             algorithm::Symbol=:LN_BOBYQA, opt_atol=1e-8, opt_rtol=1e-8,\n             maxiter=-1)\n\nFind the optimal λ value for a Box-Cox transformation of the data.\n\nWhen no X is provided, y is treated as an unconditional distribution.\n\nWhen X is provided, y is treated as distribution conditional on the linear predictor defined by X. At each iteration step, a simple linear regression is fit to the transformed y with X as the model matrix.\n\nIf a FormulaTerm is provided, then X is constructed using that specification and data.\n\nIf a LinearMixedModel is provided, then X and y are extracted from the model object.\n\nnote: Note\nThe formula interface is only available if StatsModels.jl is loaded either directly or via another package such GLM.jl or MixedModels.jl.\n\nnote: Note\nThe formula interface is defined as a package extension.\nThe MixedModels interface is defined as a package extension.\n\natol controls the absolute tolerance for treating λ as zero.\n\nThe opt_ keyword arguments are tolerances passed onto NLopt.\n\nmaxiter specifies the maximum number of iterations to use in optimization; negative values place no restrictions.\n\nalgorithm is a valid NLopt algorithm to use in optimization.\n\nprogress enables progress bars for intermediate model fits during the optimization process.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.params-Tuple{BoxCoxTransformation}","page":"API","title":"StatsAPI.params","text":"StatsAPI.params(bc::BoxCoxTransformation)\n\nReturn a vector of all parameters, i.e. [λ].\n\n\n\n\n\n","category":"method"},{"location":"#BoxCox.jl-Documentation","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"","category":"section"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"CurrentModule = BoxCox","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"BoxCox.jl is a Julia package providing an implementation of the Box-Cox transformation and generalizations thereof.","category":"page"},{"location":"#Box-Cox-transformations-of-an-unconditional-distribution","page":"BoxCox.jl Documentation","title":"Box-Cox transformations of an unconditional distribution","text":"","category":"section"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"First, we consider applying the Box-Cox transformation to an unconditional distribution. In other words, we have a vector of data that we wish to be more Gaussian in shape.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We start with the square root of a normal distribution.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"using BoxCox\nusing CairoMakie\nusing Random\nCairoMakie.activate!(; type=\"svg\")\n\nx = abs2.(randn(MersenneTwister(42), 1000))\nlet f = Figure()\n    ax = Axis(f[1,1]; xlabel=\"x\", ylabel=\"density\")\n    density!(ax, x)\n    ax = Axis(f[1,2]; xlabel=\"theoretical quantiles\", ylabel=\"observed values\")\n    qqnorm!(ax, x)\n    colsize!(f.layout, 1, Aspect(1, 1.0))\n    colsize!(f.layout, 2, Aspect(1, 1.0))\n    resize_to_layout!(f)\n    f\nend","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We fit the Box-Cox transform.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"bc = fit(BoxCoxTransformation, x)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"Note that the resulting transform isn't exactly a square root, even though our data are just the square of a normal sample. The reason for this is simple: without knowing the original sign, the square root returns all positive values and would thus not generate a symmetric distribution. The Box-Cox transformation does not eliminate the use of the analyst's discretion and domain knowledge.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"Now that we've fit the transform, we use it like a function to transform the original data.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"let f = Figure(), bcx = bc.(x)\n    ax = Axis(f[1,1]; xlabel=\"x\", ylabel=\"density\")\n    density!(ax, bcx)\n    ax = Axis(f[1,2]; xlabel=\"theoretical quantiles\", ylabel=\"observed values\")\n    qqnorm!(ax, bcx; qqline=:fitrobust)\n    colsize!(f.layout, 1, Aspect(1, 1.0))\n    colsize!(f.layout, 2, Aspect(1, 1.0))\n    resize_to_layout!(f)\n    f\nend","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We can also generate a diagnostic plot to see how well other parameter values would have worked for normalizing the data.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"boxcoxplot(bc)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"The vertical line corresponds to the final parameter estimate.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"If we specify a confidence level, then an additional horizontal line is added, which crosses the likelihood profile at the points corresponding to the edge of the confidence interval.","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"boxcoxplot(bc; conf_level=0.95)","category":"page"},{"location":"#Box-Cox-transformations-of-a-conditional-distribution","page":"BoxCox.jl Documentation","title":"Box-Cox transformations of a conditional distribution","text":"","category":"section"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We can also consider transformations of a conditional distribution. As an example, we consider the trees dataset:","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"using BoxCox\nusing CairoMakie\nusing RDatasets: dataset as rdataset\nusing StatsModels\n\nCairoMakie.activate!(; type=\"svg\")\n\ntrees = rdataset(\"datasets\", \"trees\")\nfirst(trees, 5)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"For the conditional distribution, we want to fit a linear regression to the transformed response values and then evaluate the profile likelihood of the transformation. If the StatsModels package has been loaded, either directly or indirectly (e.g. via loading GLM.jl or MixedModels.jl), then a formula interface is available. (Otherwise, the model matrix and the response have to specified separately.)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"bc = fit(BoxCoxTransformation, @formula(Volume ~ log(Height) + log(Girth)), trees)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"We can do all the same diagnostics as previously:","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"let f = Figure()\n    ax = Axis(f[1, 1]; title=\"Raw\")\n    density!(ax, trees.Volume)\n    ax = Axis(f[1, 2]; title=\"Transformed\")\n    density!(ax, bc.(trees.Volume))\n    colsize!(f.layout, 1, Aspect(1, 1.0))\n    colsize!(f.layout, 2, Aspect(1, 1.0))\n    resize_to_layout!(f)\n    f\nend","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"let f = Figure()\n    ax = Axis(f[1, 1]; title=\"Raw\", aspect=1)\n    qqnorm!(ax, trees.Volume; qqline=:fitrobust)\n    ax = Axis(f[1, 2]; title=\"Transformed\", aspect=1)\n    qqnorm!(ax, bc.(trees.Volume); qqline=:fitrobust)\n    colsize!(f.layout, 1, Aspect(1, 1.0))\n    colsize!(f.layout, 2, Aspect(1, 1.0))\n    resize_to_layout!(f)\n    f\nend","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"boxcoxplot(bc; conf_level=0.95)","category":"page"},{"location":"","page":"BoxCox.jl Documentation","title":"BoxCox.jl Documentation","text":"This last diagnostic plot suggests that λ = 0 is within the possible range of parameter values to consider.  λ = 0 corresponds to a logarithmic transformation; given that the other variables are log-transformed, this suggests that we should consider using a log transform for the response.","category":"page"},{"location":"mixed-models/#MixedModels.jl-integration","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"","category":"section"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"CurrentModule = BoxCox","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"BoxCox.jl supports finding fitting the Box-Cox transformation to a LinearMixedModel from MixedModels.jl. This support is done via a package extension and so the user pays no dependency or precompilation penalty when this functionality is not used.","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"Let us examine the classic sleepstudy dataset from MixedModels.jl. First, we load the necessary packages.","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"using BoxCox\nusing CairoMakie\nusing MixedModels\nusing MixedModels: dataset\nCairoMakie.activate!(; type=\"svg\")","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"Then we fit the traditional model used reaction time as our dependent variable:","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"model = fit(MixedModel,\n            @formula(reaction ~ 1 + days + (1 + days | subj)),\n            dataset(:sleepstudy))","category":"page"},{"location":"mixed-models/#Fitting-the-Box-Cox-transformation","page":"MixedModels.jl integration","title":"Fitting the Box-Cox transformation","text":"","category":"section"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"While this model does perform well overall, we can also examine whether the Box-Cox transformation suggests a transformation of the response.","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"bc = fit(BoxCoxTransformation, model)","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"note: Note\nFor large models, fitting the BoxCoxTransformation can take a while because a mixed model must be repeatedly fit after each intermediate transformation.","category":"page"},{"location":"mixed-models/#Choosing-an-appropriate-transformation","page":"MixedModels.jl integration","title":"Choosing an appropriate transformation","text":"","category":"section"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"Although we receive a single \"best\" value (approximately -1.0747) from the fitting process, it is worthwhile to look at the profile likelihood plot for the transformation:","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"boxcoxplot(bc; conf_level=0.95)","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"Here we see that -1 is nearly as good. Moreover, time^-1 has a natural interpretation as speed. In other words, we can model reaction speed instead of reaction time. Then instead of seeing whether participants take longer to respond with each passing day, we can see whether their speed increases or decreases. In both cases, we're looking at whether they respond faster or slower and even the terminology fast and slow suggests that speed is easily interpretable.","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"Now, the formal definition of the Box-Cox transformation is:","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"begincases\nfracx^lambda - 1lambda quad lambda neq 0 \nlog x quad lambda = 0\nendcases","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"In other words, there is a normalizing denominator that flips the sign when lambda  0. If we use the full Box-Cox formula, then the sign of the effect in our transformed and untransformed model remains the same. While useful at times, speed has a natural interpretation and so we instead use the power relation, which is the actual key component, without normalization.","category":"page"},{"location":"mixed-models/#Fitting-a-model-to-the-transformed-response","page":"MixedModels.jl integration","title":"Fitting a model to the transformed response","text":"","category":"section"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"Because reaction is stored in milliseconds, we use 1000 / reaction instead of 1 / reaction so that our speed units are responses per second.","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"model_bc = fit(MixedModel,\n               @formula(1000 / reaction ~ 1 + days + (1 + days | subj)),\n                dataset(:sleepstudy))","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"For our original model on the untransformed scale, the intercept was approximately 250, which means that the average response time was about 250 milliseconds. For the model on the speed scale, we have an intercept about approximately 4, which means that the average response speed is about 4 responses per second, which implies that the the average response time is 250 milliseconds. In other words, our new results are compatible with our previous estimates.","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"note: Note\nBecause the Box-Cox transformation helps a model achieve normality of the residuals, it helps fulfill the model assumptions. When these assumptions are not fulfilled, we may still get similar estimates, but the standard errors and derived measures (e.g., confidence intervals and associated coverage) may not be correct.","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"Finally, let's take a look at our the residual diagnostics for our transformed and untransformed models:","category":"page"},{"location":"mixed-models/#Impact-of-transformation","page":"MixedModels.jl integration","title":"Impact of transformation","text":"","category":"section"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"let f = Figure()\n    ax = Axis(f[1, 1]; title=\"Reaction Time\", aspect=1)\n    density!(ax, residuals(model))\n    ax = Axis(f[1, 2]; title=\"Speed\", aspect=1)\n    density!(ax, residuals(model_bc))\n    colsize!(f.layout, 1, Aspect(1, 1.0))\n    colsize!(f.layout, 2, Aspect(1, 1.0))\n    resize_to_layout!(f)\n    f\nend","category":"page"},{"location":"mixed-models/#QQ-plots","page":"MixedModels.jl integration","title":"QQ plots","text":"","category":"section"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"let f = Figure()\n    ax = Axis(f[1, 1]; title=\"Reaction Time\", aspect=1)\n    qqnorm!(ax, residuals(model); qqline=:fitrobust)\n    ax = Axis(f[1, 2]; title=\"Speed\", aspect=1)\n    qqnorm!(ax, residuals(model_bc); qqline=:fitrobust)\n    colsize!(f.layout, 1, Aspect(1, 1.0))\n    colsize!(f.layout, 2, Aspect(1, 1.0))\n    resize_to_layout!(f)\n    f\nend","category":"page"},{"location":"mixed-models/#Fitted-vs-residual","page":"MixedModels.jl integration","title":"Fitted vs residual","text":"","category":"section"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"let f = Figure()\n    ax = Axis(f[1, 1]; title=\"Reaction Time\", aspect=1, xlabel=\"Fitted\", ylabel=\"Residual\")\n    scatter!(ax, fitted(model), residuals(model))\n    hlines!(ax, 0; linestyle=:dash, color=:black)\n    ax = Axis(f[1, 2]; title=\"Speed\", aspect=1, xlabel=\"Fitted\", ylabel=\"Residual\")\n    scatter!(ax, fitted(model_bc), residuals(model_bc))\n    hlines!(ax, 0; linestyle=:dash, color=:black)\n    colsize!(f.layout, 1, Aspect(1, 1.0))\n    colsize!(f.layout, 2, Aspect(1, 1.0))\n    resize_to_layout!(f)\n    f\nend","category":"page"},{"location":"mixed-models/#Fitted-vs-observed","page":"MixedModels.jl integration","title":"Fitted vs observed","text":"","category":"section"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"let f = Figure()\n    ax = Axis(f[1, 1]; title=\"Reaction Time\", aspect=1,  \n              xlabel=\"Fitted\", ylabel=\"Observed\")\n    scatter!(ax, fitted(model), response(model))\n    ablines!(ax, 0, 1; linestyle=:dash, color=:black)\n    ax = Axis(f[1, 2]; title=\"Speed\", aspect=1, xlabel=\"Fitted\", ylabel=\"Observed\")\n    scatter!(ax, fitted(model_bc), response(model_bc))\n    ablines!(ax, 0, 1; linestyle=:dash, color=:black)\n    colsize!(f.layout, 1, Aspect(1, 1.0))\n    colsize!(f.layout, 2, Aspect(1, 1.0))\n    resize_to_layout!(f)\n    f\nend","category":"page"},{"location":"mixed-models/","page":"MixedModels.jl integration","title":"MixedModels.jl integration","text":"All together, this suggests that using speed instead of reaction time does indeed improve the quality of the model fit, even though the fit was already very good for reaction time. This example also highlighted the importance of the analyst's discretion: we choose a slightly different transformation than the originally estimated Box-Cox transformation in order to yield a model on a naturally interpretable scale.","category":"page"}]
}
